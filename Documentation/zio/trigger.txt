
ZIO defines a "trigger" object type, and each cset is connected to
a trigger.

Each cset in a device can use a different trigger, which is specified
as an attribute of the cset.  When the trigger fires, it acts on all
the non-disabled channels of the cset.  Only the "app-request" trigger
can act on a single channel at a time.

Please read <linux/zio-trigger.h> together with this file.

	Trigger Types
	=============

Triggers may be device-specific or generic. A few generic triggers
are part of zio-core. The "app-request" trigger fires input when
the application calls read and fires output when the application calls
write (it acts on a single channel). The "ktimer" trigger uses a kernel
timer as trigger source. The "irq" trigger uses any interrupt (e.g.,
a GPIO interrupt, or pin 10 of the PC parallel port) as trigger event.

A device-specific trigger declares to be such within its attributes.  A
device-specific trigger can only be used by csets that declare its name
as preferred trigger type.  When such csets are registered, if the
trigger is already known to ZIO, it will be activated by default instead
of "app-request".

	Trigger Operations
	==================

Trigger operations are the following:

	struct zio_ti *(*create)(struct zio_trigger_type *trig,
				 struct zio_cset *cset,
				 struct zio_control *ctrl,
				 fmode_t flags);
	void (*destroy)(struct zio_ti *ti);

Create and destroy a trigger instance for a cset. ZIO calls create() when
attaching the trigger to a cset; it calls destroy() when the trigger is
replaced by a different one or the cset is being unregistered from ZIO.
The instance structure is trigger-specific, but it must include the
generic structure zio_ti. Every time this structure is passed over, trigger
code may use container_of if it needs to access the private enclosing
structure.

	int (*config)(struct zio_ti *ti, stuct zio_control *ctrl);

The method is called by ZIO whenever the attributes for a trigger
instance are modified by the user (by writing to sysfs or otherwise).

	int (*push_block)(struct zio_ti *ti,
			  struct zio_channel *chan,
			  struct zio_control *ctrl);

This is used for output channels: when a new data block is ready, it
must be sent to the trigger so it can be output when the event fires.
Buffer code, therefore, is expected to call this trigger method.  The
function can return -EAGAIN if it has no space in the queue, or 0 on
success. If EAGAIN happens, the buffer should handle it (by storing
locally or notifying the user).

	void (*pull_block)(struct zio_ti *ti,
	  		   struct zio_channel *chan);

The method asks the trigger for a new block. It may be called by
the buffer, if it wants a block immediately. The trigger that offers
this method (which may be NULL) is responsible for storing a block
when available.  Since driver->input_cset completes asynchronously, this
method can't return a block directly.  The block that will be stored
may be shorter than what the trigger would have stored in the buffer
by itself.

        void (*data_done)(struct zio_cset *cset);

The function is called by the device, and signals the trigger that
the input or output operation on the cset is over. For input, the
trigger will push blocks to the buffer; for output it will release
the blocks.  zio-core offers zio_generic_data_done() for triggers
that don't need special handling.

	When the trigger fires
	======================

The trigger event may happen for a variety of reasons. It can be
time-driven, data-driven or whatever else.  In any case, there is
a time when the trigger fires, so input or output may happen.
(With most hardware-specific triggers, the actual input or output of
data has already happened when the trigger interrupt runs, but this
doesn't change the software flow).

Hardware-driven triggers will need to make their own work by themselves,
but ZIO offers this helper macro to loop over all non-disabled channels:

	cset_for_each(struct zio_cset *cset, struct zio_channel *ch)

The macro works like "task_for_each" or "list_for_each" in the kernel
headers.

For software-based triggers (where actual I/O happens when software
wants it to happen, even if it is in response to an interrupt), the
asynchronous code that runs the event will just need to call

	zio_fire_trigger(struct zio_ti *ti);

This function, part of zio-core, calls the internal helpers
__zio_fire_input_trigger for input or __zio_fire_output_trigger for
output. For input, block allocation is performed for each
non-disabled channel, and drv->input_cset is called.
For output, drv->outoput_cset is called.

You can refer to "zio-trig-timer" for an example of a multi-instance
generic timer and to "zio-trig-app-request" for a non-conventional
implementation based on trigger-local file_operations.
