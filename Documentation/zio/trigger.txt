
ZIO defines a "trigger" object type, and each cset is connected to
a trigger.

Each cset in a device can use a different trigger, which is specified
as an attribute of the cset.  When the trigger fires, it acts on all
the non-disabled channels of the cset.  Only the "app-request" trigger
can act on a single channel at a time.


	Trigger Types
	=============

Triggers may be device-specific or generic. A few generic triggers
are part of zio-core. The "app-request" trigger fires input when
the application calls read and fires output when the application calls
write (it acts on a single channel). The "ktimer" trigger uses a kernel
timer as trigger source. The "irq" trigger uses any interrupt (e.g.,
a GPIO interrupt, or pin 10 of the PC parallel port) as trigger event.

A device-specific trigger declares to be such within its attributes.  A
device-specific trigger can only be used by csets that declare its name
as preferred trigger type.  When such csets are registered, if the
trigger is already known to ZIO, it will be activated by default instead
of "app-request".

	Trigger Operations
	==================

(NOTE: this is still subject to fine-tuning, as we are still writing code)

Trigger operations are the following:

	struct zio_trigger_instance *(*create)(struct zio_buffer *buffer,
						struct zio_cset *cset);
	void (*destroy)(struct zio_trigger_instance *t_instance);

Create and destroy a trigger instance for a cset. ZIO calls create when
attaching the trigger to a cset; it calls destroy when the trigger is
replaced by a different one or the cset is being unregistered from ZIO.
The instance structure is trigger-specific, but it must include this
generic structure:

	struct zio_trigger_instance {
		struct zio_trigger *trig;
		struct zio_cset *cset;
	};

Every time this structure is passed over, trigger code may use container_of
if it needs to access the private enclosing structure.

	int (*config)(struct zio_trigger_instance *t_instance);

The method is called by ZIO whenever the attributes for a trigger
instance are modified by the user (by writing to sysfs or otherwise).

	int (*enqueue_block)(struct zio_trigger_instance *t_instance,
				struct zio_channel *ch,
				struct zio_control *ctrl,
				void *data, size_t len);

This is used for output channels: when a new data block is ready, it
must be sent to the trigger so it can be output when the event fires.
Buffer code, therefore, is expected to call this trigger method.  The
function can return -EAGAIN if it has no space in the queue, or 0 on
success. If EAGAIN happens, the buffer should handle it (by storing
locally or notifying the user).

	int (*space_in_buffer)(struct zio_trigger_instance *t_instance);

The method return either 0 (there is space for one block), a positive
value (the maximum size of the next block that can be enqueued) or
-EAGAIN.  This can be used by the poll file operation, to ask
whether the next write(2) will succeed or not.

	File Operations
	===============

The trigger may include a non-NULL f_ops pointer. Most trigger will
not need it, but for example "app-request" does, because it needs to
look at individual read and write calls performed by applications.
ZIO will use these file operations (instead of the buffer file operations)
when the open method of the char device detects that the active trigger
declares a non-NULL f_ops field.  These operations will most
likely fall back to buffer->f_ops for most of their actual work.

See zio-trig-app-request.c for details about how this is used.

	When the trigger fires
	======================

The trigger event may happen for a variety of reasons. It can be
time-driven, data-driven or whatever else.  In any case, there is
a time when the trigger fires, so input or output may happen.
(With most hardware-specific triggers, the actual input or output of
data has already happened when the trigger interrupt runs, but this
doesn't change the software flow).

For output triggers, the trigger instance is already hosting the data
blocks (received through the enqueue_block method), so the code will
just loop over all the channels and free such data blocks. In some cases
the trigger will need to perform the output before freeing data, in
most cases data has been prepared for DMA during enqueue_block,
so output already happened when the trigger run.

ZIO offers this help macro to loop over all non-disabled channels:

	cset_for_each(struct zio_cset *cset, struct zio_channel *ch)

The macro works like "task_for_each" or "list_for_each" in the kernel
headers.

For input triggers, the asynchronous code that runs the event will just
need to call

	zio_fire_trigger(struct zio_trigger_instance *instance);

This function, part of zio-core, internally runs "cset_for_each".
For each non-disabled channel, it calls the drv->input_block method
and the stores it in the active buffer.

You can refer to "zio-trig-ktimer" for an example of a multi-instance
generic timer and to "zio-trig-app-request" for a non-conventional
implementation based on trigger-local file_operations.

