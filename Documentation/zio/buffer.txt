
ZIO defines a "buffer" object type, so each device can exploit any
features it may offer to speed up data transfers.

Each cset in a device can use a different buffer, which is specified
as an attribute of the cset.  One instance of the buffer type exists
for each channel, and the char devices (control and data: see
device.txt) refer to the buffer.

Please read <linux/zio-buffer.h> together with this file.

	Buffer Types
	============

Buffers may be device-specific or generic. A generic buffer called
"kmalloc" is provided within zio-core; it uses kmalloc for allocation
data blocks.  Such buffer is activated by default on all new csets
being registered but is not special in any other way. You can write
your own generic buffer (and if it's better than ours, we may use it
as default buffer in future releases).

A device-specific buffer declares to be such within its attributes.  A
device-specific buffer can only be used by csets that declare its name
as preferred buffer type.  When such csets are registered, if the
buffer is already known to ZIO, it will be activated by default instead
of "kmalloc".

Sometimes people write drivers for a set of similar devices, with
similar DMA capabilities. In this case, all of them may refer to the
same device-specific buffer type; the buffer type may be registered
as a standalone kernel module.

The ZIO buffer data structures includes two sets of operations:
file_operations and buffer_operations.


	Buffer Operations
	=================

Each buffer type must provide the following buffer operations. All
of them are implemented in zio-buf-kmalloc.c, which may be used as
reference to better understand the role of each method:

	struct zio_bi *(*create)(struct zio_buffer_type *zbuf,
				 struct zio_channel *ch);
	void (*destroy)(struct zio_bi *bi);

The create() operation allocates and initializes an instance of the
buffer type. It is called by ZIO when a channel is opened for the
first time. The operation returns a zio buffer instance (zio_bi),
which is the generic descriptor of a buffer instance. ZIO handles
only zio_bi, so complex buffer structures must contain the zio_bi
structure and use container_of() to access the private enclosing
structure. create() can use default attributes of its buffer type at
creation time; a copy for this specific instance is created by
zio-core after the function returns.

destroy() deallocates a buffer instance. ZIO calls destroy() when the
channel is unregistered from ZIO or when the user assigns a different
buffer type to the channel.

When the control/data devices are closed, ZIO doesn't call destroy(), so
incoming data can queue up while the application leaves it closed
(e.g., a shell script).  Actually, the release file operation is not
handled by ZIO, so it couldn't call destroy on close even if it wanted
to.

	struct zio_block *(*alloc_block)(struct zio_bi *bi,
					 struct zio_control *ctrl,
					 size_t datalen, gfp_t gfp);
	void (*free_block)(struct zio_bi *bi, struct zio_block *block);

For input channels, a block is allocated before the trigger fires, and
it is freed when the user has read or explicitly ignored it. For
output, allocation happens on user write and free is called by the
trigger when it is done. Thus, the functions are sometimes called by
buffer code itself, and sometimes by the trigger. The generic
structure hosting a block is zio_block which contain both data
(samples) and control information.  If needed, buffers may use a more
complex structure, which will include zio_block, which is the only
structure that ZIO handles; by using container_of you can retrieve the
enclosing complex structure used in your buffer

	int (*store_block)(struct zio_bi *bi, struct zio_block *block);
	struct zio_block (*retr_block) (struct zio_bi *bi);

For input the trigger calls store_block() and the read system call issues
retr_block().  For output, the write system call runs store_block()
and the trigger may call retr_block() (although the buffer pushes to
the trigger when it receives the first data block).


	File Operations
	===============

This structure holds the file_operations used by the char devices (control
and data) for every channel using this buffer type.  When char devices are
initially opened, the open method being run is within zio-code;
it  kmallocs f->private_data before calling the buffer-specific open
method. The private data being used is:

	struct zio_f_priv {
		struct zio_channel *chan;
		enum zio_cdev_type type;
	};

All buffer file operations can thus refer to the current channel (and
its buffer and its trigger), and know if the current file is
ZIO_CDEV_CTRL or ZIO_CDEV_DATA.  Every buffer is expected to
call zio_generic_release() at the end of its own release operation, or
used zio_generic_release() directly in the file operations.

ZIO offers other generic file operations that may be enough for your
buffer code or may not. See zio-buf-kmalloc.c for a working example of
buffer file operations.
