\input texinfo    @c -*-texinfo-*-
%
% zio-manual.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make zio.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename zio.info
@settitle zio
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off
@set update-month January 2013
@finalout
@c #################################################################
@titlepage
@title ZIO User Manual
@subtitle @value{update-month}
@subtitle A kernel framework for laboratory I/O

@sp 6
@center @image{img/zio-logo, 7cm, ,zio logo, gif}
@sp 1

@author Alessandro Rubini and Federico Vaga for CERN (BE-CO-HT)
@end titlepage
@headings single

@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex tp cp
@syncodeindex pg cp

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

ZIO plans to be ``the ultimate I/O framework''.  It is being developed
on the open hardware repository at @url{http://www.ohwr.org/projects/zio}.

The framework is meant to offer a flexible interface for the
development of input and output drivers for very-high-bandwidth
devices with high-definition time stamps and a uniform meta-data
representation.

The version at time of this writing is known to compile and run with
kernels 2.6.32 onwards. We also maintain a @i{git} branch for 2.6.24,
since this is the version we are running in some production laboratories.
@c FIXME: versions
@cindex kernel, supported versions

@c ##########################################################################
@node General Concepts
@chapter General Concepts

While the design is pretty stable and we don't plan to introduce any
serious change in the code that affects our users, there are some
research ideas that we are evaluating and experimenting with.  Thus,
we want to define from the start both the words that we are using
within the framework and the ideas that will be introduced at a later
time.

@c ==========================================================================
@node Definitions
@section Definitions

@cindex block
The ZIO framework is designed to move @i{data blocks}, or just
@i{blocks} for short (not in italic from now on). A block is a sequence
of zero or more data samples with associated meta-information. Blocks
containing a single data sample are not expected to be common, as our
use case is concerned with devices that input or output several
thousand samples in a single shot, with a hardware-defined data rate
and a single time-stamp marking the beginning of the event.  Blocks
containing zero data items are not forbidden, because they can be used
to pass meta-information without associated data (e.g., TDC and DTC
devices, described later).

@cindex control
A block can flow in either the input or output direction.  The
meta-information about a block is stored in a @i{control structure} or
just @i{control} for short (again, not in italic in this document).

The ZIO code base is designed around three main items:

@table @r
@cindex device
@item Device
	A ZIO device describes one specific I/O peripheral. See
	@ref{The Peripheral Driver}.

@cindex trigger
@item Trigger
	The trigger is code concerned with firing I/O, in response to
        some event. ZIO supports both software triggers and hardware
        triggers; in the latter case the software module is used to
        configure to the device and retrieve status information.
        See @ref{The Trigger}.

@cindex buffer
@item Buffer 
	A buffer stores blocks, either input blocks
        generated by a trigger or output blocks generated by some
        injecting code One end of the buffer is always connected to a
	trigger, and the other end is usually connected to a char
	device (but ZIO buffers are not constrained to).
        See @ref{The Buffer}.
@end table

@cindex driver
The ZIO driver manages a @i{device}, which in turn may be either a
chip or a PCB (or something else). The driver is the @i{probe unit},
i.e. a batch of I/O peripherals that are plugged and unplugged as a
whole, usually based on some bus, like PCI, USB or SPI.

@cindex device
Devices include I/O channels of one or more type. A PCI board for
example may have both analogue input and digital output, while
an SPI chip will usually offer only one channel type.  A ZIO
device, thus, is described as a collection of @i{channel-sets},
or @i{csets} for short -- again, in roman font throughout this
document.

@cindex cset
A cset is a group of channels usually associated with a wire connected
to some backplane of the computer.  All channels within a cset must be
alike: same sample size and same configuration options (i.e.,
configuration values may vary across channels in the same cset, but
all of them must feature the same set, like gain and offset).

@cindex channel
The channel is the basic I/O entity, usually associated with a single
electrical connection on some backplane. The layers are displayed
in @ref{fig:layers}

@float Figure,fig:layers
@image{img/zio-layers, 8cm, , the three layers of ZIO, gif}
@end float
@sp 1

@cindex cset
The cset is the most important object for ZIO devices. Each cset is
associated with a trigger, and I/O events affects all channels in the
cset -- although you can disable individual channels as needed.

Each cset has a @i{current_trigger} attribute, which defines a trigger
type; for each cset using that trigger type, ZIO creates an instance of
the trigger. Each cset has a @i{current_buffer} attribute as well. ZIO creates
a buffer instance for each channel in the cset.  Thus, each channel
owns a buffer instance, but of the same type across the cset.

Figure @ref{fig:cset} shows a cset, the trigger and buffer types it
refers to an the instances it is using. A cset has one trigger
instance overall and one buffer instance for each channel.

@float Figure,fig:cset
@image{img/zio-cset, 8cm, , A cset with trigger and buffers, gif}
@caption{Figure 2: The cset}
@end float
@sp 1

@c ==========================================================================
@node Supported Devices
@section Supported Devices

@cindex devices, supported
This is a quick list of devices or device types that are supported in
the current version of ZIO.  This is a cursory overlook, for some of
them more information is provided in specific sections of
@ref{Available Modules}.

@table @r

@cindex zio-zero
@cindex zero device
@item zero device

	The zero device is a software-driven input and output device,
        it is used for demonstration and stress-testing. It behaves
        like @file{/dev/zero}, @file{/dev/null} and similar devices.

@cindex zio-loop
@cindex loop device
@item loop device

	The device is a collection of csets and character devices
        connected in pairs.  This is another software aid for stress testing
        and looking at the internals.  Requiring no hardware, it's a
        good tool during development of the core.  You can loop blocks
        from ZIO to ZIO, from ZIO to a char device or from a char device
        to ZIO.

@cindex zio-mini
@cindex mini device
@item mini device

	This is the last software-only device we offer. It is designed
        to be as simple as possible, to help new developers who are
        learning to write ZIO drivers.  It registers one cset with one
        channel, by default, but module parameters allow to create several
        csets and several instances of the device. With it you can also
        stress-test the ZIO bus abstraction, and interaction with @i{udev}.

@cindex gpio device
@cindex zio-gpio
@item gpio device

	The gpio device acts on an array of input and output GPIO pins.
        It relies on the Linux GPIO abstraction, so it can run in any
        system that has registered GPIO pins. The configuration is
        set with module parameters.

@cindex SPI
@item SPI devices

	Some ADC devices connected to the SPI bus are supported, it should
        be easy to add more.

@cindex uart
@cindex line discipline
@item uart device
@c FIXME line discipline

	We are working on a @i{ldisc} device driver, which however is
        not included in this release yet. It is out test-bed for
        interleaved support.


@cindex drivers, external
@cindex external drivers
@item external drivers

	There are a number of external device drivers that rely on
        the ZIO framework. They are not part of this distribution because
        they live in their own projects, and are quite specialized.
        We have at least a @i{fine-delay} module, a @i{TDC} and a fast @i{ADC}.
        What we and our mates wrote is available in @url{ohwr.org},
        but there may be other drivers that we still ignore about.

@end table

@cindex buffers
@cindex triggers
This distribution also includes a few buffers and triggers.  They are
not listed here as they are not properly device drivers.  The buffers
are generic RAM-based buffers (we offer @i{kmalloc} and @i{vmalloc},
the latter supports @i{mmap} as well), and the triggers are a set of
generic software-driven triggers: kernel timer (periodic),
high-resolution timers (both periodic and one-shot),
external-interrupt, and the transparent trigger (where I/O is driven
by either the user who tries to read or write, or by the internal
events in the device and it claims to ba self-triggered).

For more details see @ref{Available Buffers} and @ref{Available Triggers}.

@c ==========================================================================
@node Future Developments
@section Future Developments

@cindex future developments
@cindex development ideas
Before going to the details of what is implemented now, we'd like
to list the ideas we are working on, because they will reach the
ZIO framework at some time in the future. Some of them are already
in @i{beta} stage, available from @i{git} branches in our @t{ohwr} repository.

@itemize @bullet
 
@cindex input subsystem and ZIO
@item Supporting an @code{input_device} buffer type

	A buffer type may inject input events to the Linux input
        subsystem, and we feel it's an easy and interesting feature to offer.

@cindex PF_ZIO, network protocol family
@cindex AF_ZIO, network address family
@item Writing a new PF_ZIO network type.

        The protocol family @code{PF_ZIO} allows to see the whole
        set of I/O peripheral devices as a network. Such network can
        be internal to a single host, or it can span multiple hosts
        by exchanging frames for type @t{ETH_P_ZIO}.  With @t{PF_ZIO}
        each channel has a network address, with the @i{control} acting
        as link-level protocol header. This will allow applications to
        open only a single socket (or a few of them) instead of one
        or two char devices for each channel being used.
	This is already available, and is being stabilized. We
        presented it at the @i{Embedded Linux Conference Europe} in
        November 2012.

@cindex interleaved channels
@item Interleaved channels

@c FIXME: interleave
	A number of high-throughput peripherals interleave data from
        their channels. We have no support for interleaved I/O in
        the master branch, but the 100Ms ADC driver
        already uses interleaving internally. We are working to
        add support for this in ZIO, in a portable and future-proof way.
        The implementation will rely on TLV records
        (see @ref{TLV in the Control}).

@cindex interface, to abstract file operations
@item Defining the ``zio_interface'' data structure.

	The @i{interface} will abstract char device support out of
        the ZIO core, so users will be able to use different interfaces;
        the PF_ZIO protocol will therefore be able to use
        hardware-specific buffers when the device requires them.

@cindex timestamping ZIO internals
@item Generalized timestamping.

@c FIXME: timestamping the pipeline: is it done?
	We are going to add capabilities to timestamp the internal ZIO
        pipeline. This allows to measure the overhead of the pipeline
        (driver, trigger and buffer) independently of which objects are
        being used -- so you can timestamp during production as well.
        The feature will be a compile-time option, that can be enabled
        with a @i{sysfs} attribute on individual csets.

@c FIXME -- other ideas in the queue

@end itemize

@c ##########################################################################
@node The ZIO Pipeline
@chapter The ZIO Pipeline

@cindex pipeline of zio data transfers
During input and output operations, ZIO blocks travel across a
pipeline of software modules. Hoping to make the representation
clearer, we chose to stick to a consistent mnemonic color model for
our figures. Unfortunately, some older figures still need to be
converted to this color model, and we apologize for this.
@c FIXME: new color model for all figures

The color model for all of our objects is shown in @ref{fig:color}.

@float Figure,fig:color
@center @image{img/zio-define-block, 5cm, , color model for blocks, gif} @image{img/zio-defines, 6cm, , color model for ZIO objects, gif}
@end float
@sp 1

@cindex pipeline
@cindex input pipeline
@cindex output pipeline
The ZIO pipeline connects user space with the peripheral device,
and the main objects involved are the file operations in the
character device, the buffer where blocks are stored, the trigger that
sequences the actual data transfers and the peripheral driver that
is concerned with hardware operations when the trigger fires.

The whole pipeline is depicted in the @ref{fig:pipeline},
where the path of the blue blocks is shown for both input and output.
The black arrows represent function calls.

@float Figure,fig:pipeline
@center @image{img/zio-pipeline, 14cm, , the input and output pipeline, gif}
@end float
@sp 1

@cindex system calls
User space makes system calls, which are implemented by the
@code{file_operations} in the current buffer. Generic functions are
implemented in @code{chardev.c} and exported as
@code{zio_generic_fops} (currently all buffers included in the
distribution are using these operations).  This may slightly change in the
future if we introduce the @i{interface} concept, but the change
will not affect buffers which simply won't declare their file operations
any more). See @ref{Future Developments} about the @i{interface} idea.

@findex store_block
@findex retr_block
The file operations code calls @code{store_block} and
@code{retr_block} in the proper buffer instance, the buffer in turn
communicates with the trigger, and the trigger refers to the device
for the raw data transfer.


@c ==========================================================================
@node All the Steps in the Pipeline
@section All the Steps in the Pipeline

This sections details all the steps a block takes from user space
to the device and back.  You should get acquainted to the various
step when writing a ZIO module or debugging some module by your mates.

When you load the device driver, each of its cset wil receive an
instance of a trigger, and each channel in the cset an instance of a
buffer; the preferred trigger type and the preferred buffer type are
selected by the device, or the default ones are used.  When the user
changes the trigger or buffer type for a cset, the operation is
atomic: it either succeeds or it fails.  This design ensures that all
steps of the pipeline are always present, and we'll use @t{bi} as name
for the pointer to the current @i{buffer instance}, and @t{ti} as name
for the pointer to the current @i{trigger instance}.

When the data is flowing, operation of the pipeline is quite
straightforward, but there are always some corner cases to be dealt
with, so the description below is sometimes longer than expected, but
it covers all cases.

Let's start with the input direction:

@itemize @bullet

@item When a user program calls @i{read}, @i{poll} or @i{select} on
a ZIO character device, it means it is interested in data. The code in
the ZIO file operation calls @t{bi->retr_block}, which may succeed or
fail. If it fails, the device is reported as not readable; the process
may be added to a wait queue or not, according to standard Unix
semantics.  If @t{retr_block} succeeds, the block just retrieved is
managed by the @i{file operations} code until it is exhausted and
eventually freed calling @t{bi->free_block}.

@item The @t{retr_block} method lives in the buffer.
If the buffer is already hosting at least one block, it returns the
first block in its FIFO structures, and the loop closes. If not, it
checks @t{ti->pull_block}.  If the pointer is NULL, the buffer can
only wait for the trigger to autonomously produce a block; otherwise
it calls @t{ti->pull_block}.

@item Most trigger types do not implement @t{pull_block}: a time-driven
trigger or an event-driven trigger will fire by itself, whether or not
the user is reading.  But if the trigger implements
the method, then it means it wants to know when the user is asking
for input data: such a trigger may return
an incomplete block, or just use @i{that} event to fire acquisition.
In any case, @t{pull_block} does not return anything, it just
informs the trigger about the request.

@item The trigger is involved with driving actual input events, in any
way it wants. At some time, or at some event, it knows it wants input
to happen, so we say it is @i{armed}. When the trigger is armed, all
active channels in the cset have a valid @i{current block}, allocated
by the trigger. Then, the trigger notifies the event to the relevant
cset by calling @t{device->raw_io(cset)}.  A @i{transparent} trigger
will arm the device at @t{pull_block} time, and each other trigger in
its own specific way.

@item After the trigger is @i{armed}, the device is in charge. If
the device is self-timed (like a TDC or another data-driven device),
the trigger can remain armed for a while.  If the device has no
internal timing, actual input begins immediately; it may complete
synchronously or asynchronously, for example reading GPIO pins is
synchronous, but if the device starts DMA an interrupt will signal its
completion at a later time.  The @t{raw_io} device method returns 0 if
input completed synchronously, and it returns @t{-EAGAIN} to report
that data will be ready at a later time. In the former case the system
knows the trigger has fired, in the latter case ZIO knows the trigger
is still armed for this cset.

@item At some time in the future, the device that reported @t{-EAGAIN}
is done with the input operation. It thus calls @t{zio_trigger_data_done()}
(that may rely on @i{ti->data_done}).
When this happens (or if @t{raw_io} completed synchronously), the
respective trigger changes its status to @i{idle}; the active block
for each channel in the cset is stored to the respective buffer
instance, by calling @i{bi->store_block}.  According to its own
semantics, the trigger can re-arm the trigger immediately, or it may
not.

@item The buffer, in its @t{store_block} method, enqueues the block.
If there are already other blocks in the buffer, the loop is over.
If, instead, this is the first block, the buffer must awake the wait
queue, because there may be a user-space program waiting for that
data.

@end itemize

The sequence of events for output is similar, but not in all
details:

@itemize

@item When a user program calls @i{write} on
a ZIO character device, the data build up into a block, that the file
operation allocated by calling @t{bi->alloc_block}.  The details of
how the control and the data are filled are not described here (see
@ref{Details of Char Device Policies}).  When the block is full, the
code calls @t{bi->store_block}.  If the buffer reports failure, the
file is reported as not writable, and the process may be put to sleep,
according to Unix semantics. @i{poll} and @i{select} are supported in
the same way.

@item The buffer method @t{store_block} take hold of
the new block. If there already are blocks in its FIFO structure, the
new block is enqueued and nothing more is done. If it is the first
block, the buffer calls @t{ti->push_block}. If the push succeeds, the
buffer remains empty (and will try @i{push} again next time).
If the push fails, the block is enqueued.

@item The trigger, in its @t{push_block}, may accept or
refuse the push. In general, it should refuse the push if it
already has a block for the current channel, and it should accept
the push if no block is pending. A double-buffering trigger can
be implemented by properly writing @i{push}.

@item After accepting the push, the trigger may, or may not, arm
the trigger, according to its own trigger policies -- which may
include cset-wide conditions or whatever else.

@item When the trigger module wants output to be performed, it
turns in to @i{armed} state, and calls @t{device->raw_io(cset)}.
Similarly to the input case described earlier, this method
can perform I/O synchronously and return 0 to mean ``success'',
or ti can perform I/O asynchronously and return @code{-EAGAIN}.
In the latter case the trigger remains in @i{armed} state.

@item At some time in the future, the device that reported @t{-EAGAIN}
is done with hardware output, and calls  @t{zio_trigger_data_done()}
(that may rely on @i{ti->data_done}).
When this happens (or if @t{raw_io} completed synchronously), the
trigger instance becomes @i{idle} again, and it frees the blocks
for the cset by calling @t{bi->free_block}.  In general,
the trigger will then call @t{bi->retr_block} in order to be
ready to re-arm the trigger.

@item If the buffer is not able to satisfy the @t{retr_block}
request, this means it is empty. As a consequence, the next time a
block is stored to the buffer, the buffer calls @t{ti->push} to
restart a loop that has been broken.  If the buffer was completely
full, this @t{retr_block} makes some space available, and the buffer
awakes the associated wait queue.

@end itemize

We think the overall is pretty simple: we offer @i{pull} and @i{push}
to initiate a new data flow or restart one that stopped for lack of
data, but the normal flow involves just @i{store_block} and
@i{retr_block}, @i{raw_io} and @i{data_done}.

The output design, in particular, resembles what happens with network
devices. A network card will accept pushes by the kernel (the method
is called @i{hard_start_xmit} until its internal buffers are full; at
thi point it calls @i{netif_stop_queue}, and when space is available
again it calls @i{netif_start_queue}.

ZIO output is similar to network transmission, but the ZIO core knows
that the trigger can accept only one or two blocks at most; so we
chose to not require the trigger to call @i{stop} and @i{start} in the
buffer, in favour for a clean failure mode for the push,
and reuse of the same @i{retr_block} that is used for the input flow.

@c ==========================================================================
@node Lifetime of a Data Block
@section Lifetime of a Data Block

@cindex block allocation
@cindex allocation of blocks
@cindex input pipeline
@ref{fig:inpath} and  @ref{fig:outpath} show
when blocks are allocated and freed in the
input and output data paths. Time in both figures is flowing downwards.

@cindex output pipeline
The pipeline for output is similar to the input one,
but the block is allocated by
the implementation of the @i{write} system call. Note in particular
how the buffer works in exactly the same way as in the input case:
it just servers @code{store_block} and @code{retr_block} requests.


@float Figure,fig:inpath
@center @image{img/zio-input, 12cm, , input block path, gif}
@end float
@sp 1

@float Figure,fig:outpath
@center @image{img/zio-output, 12cm, , output block path, gif}
@end float
@sp 1

@c ##########################################################################
@node The Bus Abstraction
@chapter The Bus Abstraction

@cindex bus, use in ZIO
The ZIO core module is called @t{zio.ko} and it creates a new @i{bus}
item in Linux.  A @i{bus} is a software abstraction for kernel-related
software modules; it splits the role of the @i{device} from the role
of the @i{driver}.  In order to have a new peripheral working in your
system you thus need both items: the @i{driver} is in charge of any
@i{device} that appears in the system, while the @i{device} is a data
structure that describes the parameters of the specific hardware
instance.  The two structures are bound by calling a @i{match}
function, that is at the core of the bus abstraction. If the device
and the driver match, the driver is asked to manage the new device
instance.

@cindex multiple devices
Even if no physical @i{bus} is involved with ZIO, by relying on this
software abstraction we are able to deal with several devices of the
same type. Our use case involves control systems where more than one
instance of the same PCI card is installed in each host.  Actually, by
distributing our hostless I/O devices using a field-bus, we foresee
the need to register a few hundred ZIO devices, to be driven by the
same driver.

@cindex modules, structure of
To make an example, let's see how to set up a ZIO module driving a PCI
I/O card.  Since PCI is a @i{bus} in Linux, you'll need to register a
PCI @i{driver} to hook to any card present in the system (in this case
the associated @i{device} is created by the PCI controller, when it
scan the physical bus).  The @i{probe} function of your PCI driver,
then, will register a ZIO @i{device}.  In addition to registering a PCI
@i{driver}, your kernel module also needs to register a ZIO @i{driver}
for your hardware, so that Linux calls its @i{probe} function
for every ZIO @i{device} that matches.

@cindex match function in ZIO bus
The ZIO bus is just a software abstraction, so its own @i{match}
function is just comparing the two names: if a device and a driver
register the same name string, they match.  This is exactly what
happens with the @i{platform bus}, a software-only bus implementation
used in every Linux system to take care of peripherals that are
directly connected to the computer system, without capabilities for
auto-discovery.

@cindex registering ZIO devices
@cindex registering ZIO drivers
So, in general, in order to create a ZIO peripheral, you need to
register both a @i{device} and a @i{driver}, sharing the same name.
This is clearly visible in simple modules like @t{zio-zero} and
@t{zio-gpio}, where the @i{init} function of the module registers both
data structures.  Nothing prevents another kernel module from
registering a new instance of the @i{zero} or @i{gpio} device (or both).

You can experiment with this concept using @t{zio-mini},
which actually registers more than one @i{device}
associated to its own @i{driver}.

@c ##########################################################################
@node ZIO data model
@chapter ZIO data model

@cindex data model
This chapter defines in detail the data model of ZIO. The
unconventional data model is the main idea behind the ZIO project,
together with the use of a real @i{bus} abstraction.

@c ==========================================================================
@node The Block
@section The Block

@cindex block
@cindex samples
Our typical use case handles several samples at the same time. We need
to manage thousands or even millions of samples at the same time,
because I/O is performed at hardware level (within an FPGA) while
the Linux driver is only concerned with passing data around.

For this reason ZIO defines a structure called @i{block}.  All data transfers
within ZIO happen in the context of a block, which is the atomic data
item.  A block includes both the actual data and the @i{meta-data} associated
with the input or output event.  Inside ZIO, no data ever travels without
associated metadata.  This design choice allows I/O data to be
transferred through unaware transport channels: only the endpoints need
to agree about what the actual payload is. More on this later.

@cindex block
The block is made up of two main parts: the data itself, called simply @i{data}
throughout the ZIO framework (including this manual) and the meta-data,
called @i{control} or @i{ctrl} from now on.  The block can be depicted
like this:

@center @image{img/zio-block, 3cm, , simple drawing of a block, gif}

@tindex zio-buffer.h
At C-language level, the block structure is defined in
@code{zio-buffer.h}, because buffers are the main ZIO object involved with
storage of blocks. This is the actual definition:

@tindex zio_block
@example
   struct zio_block {
           unsigned long           ctrl_flags;
           void                    *data;
           size_t                  datalen;
           size_t                  uoff;
   }; 
@end example

The meaning of the fields is as follows:

@table @code
@item ctrl_flags

	The field includes a pointer to the control structure and one flag
        bit, described below. 

@item data

	The pointer to actual data associated with this block. May be
        NULL for TDC or DTC devices.

@item datalen

	The length of the memory area where @i{data} points. May
        be zero for TDC or DTC devices.

@item uoff

	@i{User offset}. This field is used to track partial data,
        typically when user-space produces or consumes the block.
        Both endpoints of the ZIO pipeline can use this field, as
        the block never hosts partial data while within ZIO.

@end table

@cindex cdone
The flag bit hidden in @i{ctrl_data} is called @t{cdone}, and
is the counterpart of @i{uoff}: when a block is being produced or
consumed we need to track the status of the control. Unlike data,
the control is atomic: no partial controls ever exits, and one bit
is enough.

We chose to coalesce the pointer to control and the @code{cdone} bit
in a single filed in order to avoid wasting bytes and/or break alignment
of the structure. The same trick is used in the @i{rbtree} implementation
within the Linux kernel, and it is pretty efficient.

@tindex zio-buffer.h
@code{zio-buffer.h} defines the following macros to access parts
of the @code{ctrl_flags} field:

@findex zio_get_ctrl
@findex zio_set_ctrl
@findex zio_is_cdone
@findex zio_set_cdone
@smallexample
#define zio_get_ctrl(block) ((struct zio_control *)((block)->ctrl_flags & ~1))
#define zio_set_ctrl(block, ctrl) ((block)->ctrl_flags = (unsigned long)(ctrl))
#define zio_is_cdone(block)  ((block)->ctrl_flags & 1)
#define zio_set_cdone(block)  ((block)->ctrl_flags |= 1)
@end smallexample

As you expected, @code{ctrl} is a pointer and @code{cdone} is a single bit.
A typical user of this is the @i{read}
file operation.  See @ref{Accessing ZIO from User Space}.

@c ==========================================================================
@node The Control Structure
@section The Control Structure

@cindex control structure
@cindex size of control structure
The @i{control} is the container of meta-information used to describe
a block of data. Its size is fixed to 512 bytes, with the optional
addition of TLV records at the end. Such @i{type-length-value} records
are not used in the current implementation, but they are designed
to introduce no incompatibilities on ZIO modules developed externally.
More information about this is in  @ref{TLV in the Control}.

The layout of the control is shown in @ref{fig:control}.

@float Figure,fig:control
@center @image{img/zio-control, 7cm, , image of zio control, gif}
@end float
@sp 1


@cindex monitoring application
The control structure is fixed both to simplify communication with user
space and to support generic applications. Such generic tools may
perform monitoring or other
operations without the need to know device internals.  A similar
approach is used by the @i{event} devices in the input subsystem of
the Linux kernel.

@cindex meta-information
The control is designed to offer the full meta-information needed to
describe a block. In includes the complete global identification
of the channel, as well as the name and parameters for the 
current trigger. Applications can thus pass around a
block without knowing what it is; thus, knowledge about device and
trigger details can be concentrated in a single place, without the
need to spread information to all actors in the input/output pipeline.

@cindex offline data management
By using a control structure (i.e., zio blocks in their entirety)
ZIO users can perform
both offline data generation and offline data analysis. A program
may prepare an output waveform in advance and ask generic tools to
deliver it to the device; similarly, acquisition may be performed by
generic tools that concentrate data from a set if I/O computers to a
data center where programs that know the hardware can digest all data
blocks.

@cindex control structure
@tindex zio-user.h
The control structure is defined in @code{zio-user.h} because it
must be accessed by both kernel and user space. The definition includes
a few sub-structures, to ease logical grouping of information.
This is the current definition (version 1.0 of the control block):

@tindex zio_control
@smallexample
struct zio_control {
        uint8_t major_version;
        uint8_t minor_version;
        uint8_t zio_alarms;     /* alarms are persistent, until somebody */
        uint8_t drv_alarms;     /* clears them writing to a sysfs attribute */

        /* byte 4*/
        uint32_t seq_num;       /* block sequence number */
        uint32_t nsamples;      /* number of samples in this data block */

        /* byte 12 */
        uint16_t ssize;         /* sample-size for each of them, in bytes */
        uint16_t nbits;         /* sample-bits: number of valid bits */

        /* byte 16 */
        struct zio_addr addr;

        /* byte 48 */
        struct zio_timestamp tstamp;

        /* byte 72 */
        uint32_t mem_offset;    /* position in mmap buffer of this block */
        uint32_t reserved;      /* possibly another offset, or space for 64b */
        uint32_t flags;         /* endianness etc */

        /* byte 84 */
        /* Each data block is associated with a trigger and its features */
        char triggername[ZIO_OBJ_NAME_LEN];

        /* byte 96 */
        struct zio_ctrl_attr attr_channel;
        struct zio_ctrl_attr attr_trigger;

        /* byte 496 */
        struct zio_tlv tlv[1];
        /* byte 512: we are done */
};
@end smallexample

This is the meaning of all the fields. Please note that some of
the fields are not yet being filled by the core.

@table @code

@cindex version numbers in ZIO
@item major_version
@itemx minor_version

	The version is currently 1.0, as defined by @code{ZIO_MAJOR_VERSION}
        and @code{ZIO_MINOR_VERSION} (in @code{zio.h}). The version is used
        to ensure all actors agree on the meaning of the fields.
        We ensure that all minor version changes will be compatible (for
        example, 1.1 may have new flags that can be ignore by older code).
        Any incompatible change will force an upgrade of the major number,
        but we plan no such change in the foreseeable future -- we had
        enough experience with the 0.x versions already, and we are confident
        we covered all needs already.

@cindex alarms
@item zio_alarms
@itemx drv_alarms

	Two masks of active alarms. Alarms can be set by any module in the
        pipeline, but they can only be cleared by writing to the
        @i{sysfs} attribute of each channel.  They are not currently being
        used, though.
@c FIXME alarms

@cindex sequence numbers in control structures
@item seq_num

	Block sequence number. It starts at 1 when a channel
        is created, and it is incremented at each I/O event. The value 0 is
        reserved as a signal that the sequence number is not used by the
        entity that generated the block (e.g., user space, for output blocks).

@cindex size of data samples
@cindex sample size
@item nsamples
@itemx ssize
@itemx nbits

	Number of samples, sample size in bytes, and number of bits in
        each sample.  The
        fields are used to describe the data itself. Sample size
        and sample bits are both needed because we may have something like
        5-bit samples aligned in 32-bit words. The number of bits is a
        device attribute: drivers may allow to change them at run-time.
        The sample size is however immutable for the lifetime of a cset.

@cindex address of a channel
@cindex channel, address
@item addr

	The address is a 32-byte data structure that allows to uniquely
        identify the channel associated to this data block. It is
        described separately in @ref{ZIO Address}.

@cindex timestamp
@item struct zio_timestamp tstamp

	The timestamp associated with this input or output event. For
        input, the trigger must fill it, and it may be software-generated or
        hardware-generated.  For output, some triggers use it and some
        don't (for example, and external-irq trigger won't use pre-set
        timestamps).  The internals of this structure are defined later,
        in @ref{The Time Stamp}.

@cindex mmap support
@item mem_offset

	If the buffer supports @i{mmap}, this is the memory offset of
        the data in the buffer's storage area. Please note that the
        @i{data} pointer in the block structure is still valid: kernel
        users should refer to @t{block->data}, while user space can
        use @t{ctrl->mem_offset} while relying on @i{mmap}.

@item flags

	The flags specify features of the data block. See below
        for currently defined flags.

@cindex name of device and trigger
@item triggername

	Name of the current trigger. For input, the name
        is filled by ZIO, for output, ZIO ignores it (so it can be
        left blank). To change the trigger you should write to
        @t{current_trigger} in @i{sysfs}.

@item attr_channel
@itemx attr_trigger

	Attributes for the channel and the trigger. Each structure
        is 200 bytes long and includes both standard and extended attributes.
        The attributes are described in @ref{The Attributes}.

@item tlv

	The TLV record is normally zeroed. Special csets may need more
        information than what the control can host, and in this case
        this field is used. See @ref{TLV in the Control} for more information.

@end table

@cindex size of control structure
The size of the control structure is exactly 512 bytes, as defined at
the inception of the ZIO project, and this is verified by a
compile-time check, to ensure nobody changes this in error while
working on a new version. Actually, the check already triggered during
development: a proposed layout failed because of different alignment
constraints on different architectures.

We currently define the following flags, in @code{zio-user.h}:

@table @code

@cindex flags in control structure
@cindex endianness of data
@item ZIO_CONTROL_LITTLE_ENDIAN
@itemx ZIO_CONTROL_BIG_ENDIAN

	These are used to identify how data is written in this block.
	For input channels, data is produced in native endianness;
        for output channels the applications must convert everything
        to native endianness (i.e., ZIO doesn't fix data in kernel space).
        Both these flags are endian-agnostic, so a endian-aware application
        may read the @code{flags} field as a 32-bit integer, and apply
        endian conversion to all other fields if needed.

@cindex alignment of data samples
@item ZIO_CONTROL_MSB_ALIGN
@itemx ZIO_CONTROL_LSB_ALIGN

	The flags specify where the active sample bits (@code{nbits})
        are placed within the bytes of a sample (@code{ssize}). Both
        flags are not 0; if neither is set the alignment is unspecified.

@end table



@c --------------------------------------------------------------------------
@node ZIO Address
@subsection ZIO Address

@cindex address of a channel
The @code{zio_addr} structure is designed to uniquely identity
a channel.  Its main purpose is to allow generalized routing of the
blocks to the output channels, as well as traceability of the source
of any input data.

@cindex PF_ZIO
@cindex AF_ZIO
@tindex sockaddr_zio
The chosen layout for @t{zio_addr} is matching @t{sockaddr_zio},
the addressing structure used for the @t{PF_ZIO} implementation,
using sockets to route I/O blocks.

This is the definition of @t{zio_addr}:

@tindex zio addr
@smallexample
struct zio_addr {
        uint16_t sa_family;
        uint8_t host_type;      /* 0 == local, 1 == MAC, ... */
        uint8_t filler;
        uint8_t hostid[8];      /* MAC or other info */
        uint32_t dev_id;        /* Driver-specific id */
        uint16_t cset;          /* index of channel-set within device */
        uint16_t chan;          /* index of channel within cset */
        char devname[ZIO_OBJ_NAME_LEN];
};
@end smallexample

The fields have the following meaning:

@table @code

@item sa_family

	Currently unused in the control, this is meant to be @t{AF_ZIO}
        in all contexts where this structure is called @t{sockaddr_zio}.
        By having the same layout in the control block we simplify conversions
        between the I/O world and the networking world.

@item host_type
@itemx filler
@itemx hostid

	The first two bytes are used as @i{class} identifiers for
        the following @t{hostid}. Currently we only support type 0,
        which means @i{local delivery}; though ignored, all other
        bytes are expected to be 0 as well. When @t{PF_ZIO} will route
        frames over ethernet, we'll be able to use @t{hostid} as a MAC
        address. We chose to use one byte only for @t{host_type} to
        avoid endianness problems; if needed, @t{filler} can be used as
        a subclass of the host type.

@cindex index of cset and channel
@cindex dev_id
@cindex device name
@item dev_id
@itemx cset
@itemx chan
@itemx devname

	These four fields allow to uniquely identify the channel within
        the current host. The @code{devname} is a 12-byte string
        that identifies the driver producing
        or consuming data; @code{dev_id} is a driver-specific field
        used to identify different instances of the same driver, @code{cset}
        and @code{chan} are the indexes of cset and channel within the
        device.

	The @code{dev_id} field is used differently by different drivers:
        software-only drivers like @t{zio-zero} and @t{zio-mini} just count
        starting from zero, while PCI cards use the @i{bus} and @i{defvn}
        identifiers as geographical numbering. 

	For input, all fields are set by ZIO; for output they are ignored
        if data reaches ZIO through char devices. The network interface
        of the framework will use the fields to route data to the channel
        associated with the output block.

@end table

@c --------------------------------------------------------------------------
@node The Time Stamp
@subsection The Time Stamp

@cindex timestamp
Time stamps in ZIO are represented by @code{struct zio_timestamp},
defined in @code{zio-user.h} because it is shared with user space.
It is is made of 3 64-bit fields:

@tindex zio_timestamp
@example
struct zio_timestamp {
        uint64_t secs;
        uint64_t ticks;
        uint64_t bins;
};
@end example

The meaning of the three fields is channel-specific, in order to cater
for any hardware requirements without imposing conversions in kernel
space.  We have, however, some suggestions for use of the fields in
a consistent way:

@table @code
@cindex seconds in timestamps
@item secs

	The field should be used to host a TAI value, i.e.
        the number of seconds since Jan 1, 1970. The field is 64-bits
        wide to preserve alignment, to survive 2038 and
        and to allow for a different choice
        of the epoch, if needed.  When ZIO uses software timestamping
        for input channels, the field hosts the @code{tv_sec} value
        of a @code{struct timespec}.

@cindex nanoseconds in timestamps
@item ticks

	The field should be used to host a nanosecond count, if this
        choice makes sense for the hardware at hand. If you need to
        use a scalar nanosecond value, without a separate @i{seconds}
        component, this is where to host the value, leaving @t{secs}
        zeroed.

@cindex hardware-specific timestamps
@item bins

	This field should be used for any high-precision number as used
        in the hardware. It may also be the only non-zero field, for
        example if the hardware timestamp is taken from a custom counter
        without a second or nanosecond component, if it fits in 64 bits.

@end table

@cindex White Rabbit
For example, @i{White Rabbit} devices use hardware timestamps made up
of three 32-bit values: seconds, nanoseconds with a granularity of 8ns
or 16ns and phase offsets, usually converted to
picoseconds within the 8ns or 16ns
interval.  In this case, ZIO timestamps will store the seconds in
@code{secs}, the nanoseconds in @code{ticks}, though with a granularity
of 8 or 16 nanoseconds, and the phase in the @code{bins} field.
This setup allows generic ZIO users to still get most
of the information, while our application can combine
@i{ticks} and @i{bins} to get the full resolution provided by
the hardware.

@c --------------------------------------------------------------------------
@node TLV in the Control
@subsection TLV in the control

@cindex tlv structures
@cindex extended control structure
The control structure already includes a TLV record at the end. This
is currently unused, but we'll need to use TLV records in future
versions.  This section describes our plans and how the introduction
of TLV will affect developers of external ZIO modules.

The need for extending the control comes from interleaved
acquisition. Some input or output devices exchange buffers where
data is interleaved between the channels, but each channel has
its own attributes, like gain and offset.  We may use a cset with
a single interleaved channel, but this has two problems: on one
side 32 device attributes may not be enough, and on the other
we need to describe how physical channels are mapped to the interleaved
data set.

The initial idea was to use several control structures attached to a
single block, one control per interleaved channel. Actually, moving
around 512 bytes to convey what may be just one attribute (4
bytes) seems overkill. Besides, being restricted to the "control" as
it is now is not future-proof.

After serious discussion considering real use cases, we found that the
best approach is extending the control with a TLV structure.  This
gives flexibility and generality at the same time: any user who
ignores some type can just use the length to skip over the data (but
still carry everything to others if the specific user is only one
step in a communication channel).

Thus, the last 16 bytes of the control, which were unused
are the first @i{lump} of a TLV chain.

A TLV record is defined like this, in @t{zio-user.h}:

@tindex zio_tlv
@example
struct zio_tlv {
        uint32_t type;          /* low-half is globally assigned */
        uint32_t length;        /* number of lumps, including this one */
        uint8_t payload[8];
};
@end example

While 32 bits for the type and length may seem overkill, the choice is
meant to have 8-byte alignment in the payload to prevent
inconsistencies between 32-bit and 64-bit hosts.

The type is split into globally-assigned and locally-assigned numbers.
We reserve to define new types in the low half of the range in future
versions of ZIO, while our users are free to use any new TLV they need
in passing special meta-data throughout the ZIO pipeline.

Type 0 is the terminator. All TLV sequences must end with 16 bytes of
zeroes.  The unextended control, with its trailing zeroes, is
thus already TLV-compliant.

Type 1 is "read more". Its length is always 1 lump and its content
is a 32-bit count of how many bytes of TLV follow after this lump (the
remaining 4 bytes are unused).  Thus, when a control is augmented
with trailing TLV data, it will feature this @i{read more} lump.
The consumer of the control
will be able to read all the trailing data with a single system
call.

@unnumberedsubsubsec Effect on device drivers

When we'll introduce TLV support in ZIO core, we'll simply add a
@i{controlsize} field to the cset structure. So your driver can state
the overall size of the control and exchange extra metadata with
user space.  If you are not using this feature your code will not
be affected and will work perfectly after recompilation under the new
ZIO version.

Current drivers will work unchanged, because the core will turn an
unspecified @i{controlsize} to 512 at registration time.

Buffer modules won't be affected, as long as they use the provided ZIO
helpers to allocate the control structure.  If buffer modules
need to allocate the control in a special way, they should call
@t{zio_get_control_size(cset)} to be future-proof. This for example
applies to the @t{PF_ZIO} buffer, which needs to store the control
in the socket buffer it allocates through the network subsystem.

Generic trigger drivers won't be affected because they only look
in trigger attributes in the base control.


@unnumberedsubsubsec Effect on user space

User space code designed to work with a specific driver won't be
affected by the change, because the control size is not going to
change.  Current code will continue working as well as future code
that doesn't need to use TLV records.  Needless to say, user-space
code designed to work with a device that uses TLV must be aware of
the TLV records.

Generic user space tools, that use the ZIO abstraction to work with
any I/O peripherals, on the other hand, need to take care of TLV
extensions using the suggested ZIO protocol. Such protocol already
works with the unextended control, and actually it is already used by
the example programs in the @i{tools} subdirectory.  Clearly, 
generic code that only manages data ignoring metadata is not affected.

For the input direction, generic code that reads a ZIO control device
must work like this:

@itemize @bullet

@item Read 512 bytes (sizeof zio_control);
@item Check the first TLV lump, which is guaranteed to be type 0 or 1;
@item If it is 1 (@i{read-mode}), read the trailing part of the control.

@end itemize

For the output direction, generic code receives metadata from
elsewhere and sends it to the device. If metadata
is concatenated with data, because it is streamed through some other
communication mechanism, generic code needs to follow the
same procedure described above.


This is how parser code should be implemented. But, again, please
remember that in most cases your control will be unextended and you
can just ignore TLV extensions:

@example
    struct zio_tlv *tlv = ctrl->tlv;

    while (tlv->type != 0) {
          switch(tlv->type) {
          case ZIO_TLV_READ_MORE: /* 1 */
                read( <source>, tlv + 1, tlv->payload32);
                break;

          case ....
          }
          tlv += tlv->length;
    }
@end example

The code above assumes native endianness, which always applies when
working on the local host. If you scan remote blocks, you should
convert all values using the endianness information from @t{ctrl->flags}.


@c ==========================================================================
@node The Data
@section The Data

@cindex data block
The data pointed-to by a control structure is just opaque data for
ZIO.  For output, only the device needs to make sense of it (or just
pass it hardware without knowing what it is); for input, the
final destination of the data will use it according to the
device/cset/channel it originated from, and the information about
sample size, bits and alignment found in the control structure.

In practice, only the endpoints of the pipeline need to know what the
data is (usually relying on the metadata provided in the control
structure.  Everything else in ZIO works with blocks without knowing
what is the payload at hand.

@c ##########################################################################
@node Accessing ZIO from User Space
@chapter Accessing ZIO from User Space

ZIO transfers blocks to and from user space using char devices. Each
channel is associated with two char devices: one for data and one for
metadata.

An alternative implementation, currently in beta stage, is @t{PF_ZIO}:
a protocol family that uses a specific buffer type (in the module
@t{zio-buf-socket.ko}) to offer I/O capabilities through sockets.
This is the work of Simone Nellaga, and will be integrated in the
master branch of the ZIO repository as soon as it is stabilized.

@c ==========================================================================
@node Details of Char Device Policies
@section Details of Char Device Policies

The default user-space interface of ZIO is based on character devices.
The framework registers two devices for each channel: one is used
to exchange the control, and the other to exchange the data. The name
of the device is automatically generated from the name of the driver,
its @i{device_id} field, the cset number and the channel number.

For example, cset 0 of the @i{zzero} device has three channels, and
they appear as follows:

@smallexample
   spusa.root# ls -l /dev/zio/zzero-0000-0-*
   crw------- 1 root root 250, 0 Nov 30 13:12 /dev/zio/zzero-0000-0-0-ctrl
   crw------- 1 root root 250, 1 Nov 30 13:12 /dev/zio/zzero-0000-0-0-data
   crw------- 1 root root 250, 2 Nov 30 13:12 /dev/zio/zzero-0000-0-1-ctrl
   crw------- 1 root root 250, 3 Nov 30 13:12 /dev/zio/zzero-0000-0-1-data
   crw------- 1 root root 250, 4 Nov 30 13:12 /dev/zio/zzero-0000-0-2-ctrl
   crw------- 1 root root 250, 5 Nov 30 13:12 /dev/zio/zzero-0000-0-2-data
@end smallexample

The exact name, unfortunately, depends on the version of @i{udev} you
are running (older versions did not create the directory @i{/dev/zio}).

The role of the two devices is as represented in figure
@ref{fig:cdev}.  The meta-data and data are strictly ordered in time,
but applications can choose to read either one or both.  For input, if
you only read one device, the other is discarded; the framework makes
all devices readable when a block is available, and users can choose
what to read -- after you read some of the data, the next control read
will wait for the next block.  For output, if you only write data the
default control is used; if you write the control you replace the
default control.

@float Figure,fig:cdev
@image{img/zio-cdev, 15cm, , the two char devices, gif}
@end float
@sp 1

This split allows simple programs to just ignore the metadata and
retrieve unadorned data in the usual way: @i{cat}, @i{dd}, @i{hexdump}
are all good tools for simple diagnostics of both input and output.
More refined applications that need to deal with meta-data can afford
the extra burden of opening a second device. Example tools to access
ZIO data are described in @ref{User Space Utilities}.

You can think of this approach as what you normally do with industrial
food items. The envelope describes the specific content (including the
timestamp, name, quantity and weight of each item), and you can choose
to read the envelope or not; similarly you can choose to eat the food
or not, and sometimes you make the choice only after reading the
envelope.  

Different buffer types can offer different functionalities; for example
the @i{vnalloc} buffers supports @i{mmap} by means of the @t{mem_offset}
field in the control. Applications can @i{mmap} the whole buffer, so
they can read the control and just access the data. This is represented
in @ref{fig:mmap}.

@float Figure,fig:mmap
@image{img/zio-buffer-mmap, 15cm, , the vmalloc buffer and char devices, gif}
@end float
@sp 1

An attribute of the @i{vmalloc} buffer, can turn it into a
real circular buffer: individual buffer instances can merge
(sticks together)
several data blocks, in order to immediately release some control
structures.  The user may activate the attribute if the application knows
it won't need meta-data for every block: if you know you acquire at
1kHz, for example, time-stamping the first sample may be enough,
whereas further streaming is self-timed.  The attribute doesn't break
the ZIO data model because whenever a new data block arrives it is
stuck to the previous data by releasing the new control and increasing
the block size of the previous block; when a block enters an empty
buffer, its own control is preserved (but its own @t{nsmaples} field may
be increased later if another data blob is merged to it). The @i{control +
data} abstraction will thus continue working towards user space. This
situation is shown in @ref{fig:circ}.

@float Figure,fig:circ
@image{img/zio-buffer-data, 15cm, , the circular buffer and char devices, gif}
@end float
@sp 1

@c ==========================================================================
@node User Space Utilities
@section User Space Utilities

The distribution includes a few device-independent tools in the
@i{tools} subdirectory.

The most important one is @t{zio-dump}: a program that reads pairs of
ZIO devices and prints to @i{stdout} both the meta-data and the data
it finds.

The following example shows the output of @i{zio-dump} reading
three pairs of devices, that refer to the three channels of cset 0
of @i{zzero}. The first channel returns zeroes, the second is
random and the third is sequential; the current trigger is the
timer, with a 2-second period.

@smallexample
   spusa.root# ./tools/zio-dump /dev/zio/zzero-0000-0*
   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 0
   Ctrl: seq 603, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278753.419850926 (0)
   Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 1
   Ctrl: seq 603, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278753.419850926 (0)
   Data: 4b 01 7f a7 a5 69 fa 6a e0 90 b2 53 89 de 2e 46

   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 2
   Ctrl: seq 603, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278753.419850926 (0)
   Data: a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af

   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 0
   Ctrl: seq 604, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278755.419925778 (0)
   Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 1
   Ctrl: seq 604, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278755.419925778 (0)
   Data: 7f 49 eb df 1e 32 94 3b 2f c7 99 cb e4 97 cd 7b

   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 2
   Ctrl: seq 604, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278755.419925778 (0)
   Data: b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf
@end smallexample

The following example shows @i{zio-dump} reading one block only
(@t{-n 1}) from channel 2, showing the attributes as well (@t{-a}):

@smallexample
   spusa.root# ./tools/zio-dump -n 1 -a /dev/zio/zzero-0000-0-2*
   Ctrl: version 1.0, trigger timer, dev zzero-0000, cset 0, chan 2
   Ctrl: seq 686, n 16, size 1, bits 8, flags 01000001 (little-endian)
   Ctrl: stamp 1354278919.419898276 (0)
   Ctrl: device-std-mask: 0x0001
   Ctrl: device-std-0   0x00000008         8
   Ctrl: trigger-std-mask: 0x0002
   Ctrl: trigger-std-1   0x00000010        16
   Ctrl: trigger-ext-mask: 0x0001
   Ctrl: trigger-ext-0   0x000007d0      2000
   Data: d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df
@end smallexample

The attributes above show that the block size is 16 samples and the
@t{ms-period} attribute of this instance is 2000. Each attribute for
the device and the trigger appear as a named file in @i{sysfs}:

@smallexample
   spusa.root# ls /sys/bus/zio/devices/zzero-0000/zero-input-8/trigger/
   enable  ms-period  name  post-samples  power/  uevent
@end smallexample

The mapping between names and attribute positions is available by using
the proper defines in source files. We'll offer a way to see the mapping
from @i{sysfs} in future versions.

An alternative to @t{zio-dump} is @t{zio-cat-file}: it receives a
single file name on the command line, and copies it to @i{stdout}
using @i{mmap} if so supported.   The program works by
opening the ZIO control file associated with the named data file,
using the meta-information in there to time data accesses. If your
buffer is @i{vmalloc} or any other @i{mmap}-capable buffer, the
tool will memory-map the data device instead of reading it:

@smallexample
spusa.root# echo vmalloc > \
     /sys/bus/zio/devices/zzero-0000/zero-input-8/current_buffer
spusa.root# ./tools/zio-cat-file /dev/zio/zzero-0000-0-2-data  3 | od -t x1z
./tools/zio-cat-file: trasferred 3 blocks, 48 bytes, 0.000017 secs
0000000 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f  >................<
0000020 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af  >................<
0000040 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf  >................<
0000060
@end smallexample

By looking at the source code or using @i{strace} you can verify how
data is retrieved my memory mapping instead of reading.

@c ##########################################################################
@node Accessing ZIO from Kernel Space
@chapter Accessing ZIO from Kernel Space

Still to be written. Feel free to express your interest in this
chapter to the mailing list.

@c ##########################################################################
@node Internals
@chapter Internals

This chapter details the design ideas and data structures that make up
the three main ZIO objects.  It is what you need to know in order to
write your own ZIO modules, to be accompanied with references to the
real code part of the ZIO software distribution.

The section about devices includes the description of csets and
channels.

@c ==========================================================================
@node Naming Conventions
@section Naming Conventions

To avoid confusion in the terminology used in ZIO code and
documentation, we list here the types and data structures used in
ZIO.  For each item we list the structure name (without @t{struct}), the
name (english word) we consistently use in all documentation and the
preferred name for pointers to that data structure, used in the code.

@multitable @columnfractions .25 .2 .1 .45
@headitem Struct name or C type @tab Name  @tab Var name  @tab Description

@item zio_device
@tab full-device 
@tab zdev 
@tab The overall I/O device, either a board or a  chip.

@item zio_cset
@tab cset
@tab cset
@tab Part of a device; a group of channels with the same physical features. 

@item zio_channel
@tab channel
@tab chan
@tab Part of a cset; it is the single data stream endpoint, input or output. 

@item zio_device_operations
@tab device operations
@tab d_op
@tab Device-specific methods that act on attributes and data blocks. 

@item zio_buffer_type
@tab buffer type
@tab zbuf
@tab Description of a buffer. 

@item zio_bi
@tab buffer instance
@tab bi
@tab Instance of a buffer type associated to a specific channel. 

@item zio_buffer_operations
@tab buffer operations
@tab b_op
@tab Methods of a buffer type: instance creation and destruction, block allocation etc.

@item zio_trigger_type
@tab trigger type
@tab trig
@tab Description of a trigger, i.e. a generator of I/O events according to some rules.

@item zio_ti
@tab trigger instance
@tab ti
@tab Instance of a trigger type associated to a specific cset.

@item zio_trigger_operations
@tab trigger operations
@tab t_op
@tab Methods of a trigger type. See @ref{The Trigger}.

@item void *
@tab data @i{or} samples
@tab data
@tab A memory area hosting actual I/O data.

@item zio_control
@tab control
@tab ctrl
@tab A binary data structure used to exchange meta-data with user space.

@item zio_block
@tab block
@tab block
@tab A container for both data and control. In ZIO, all I/O data is always handled within blocks.

@item zio_obj_head
@tab head
@tab head
@tab All ZIO objects begin with this sub-structure, to ease common management.

@item zio_cdev_type
@tab -
@tab -
@tab An enumeration to identify type of a char device (control or data).

@item zio_f_priv
@tab -
@tab -
@tab Set as private_data in all open files. includes @t{cdev_type} and @t{bi}.

@item zio_attribute_set
@tab attribute set
@tab zattr_set
@tab Attributes of a ZIO object (device, cset, chan, ti, bi)


@end multitable

@c ==========================================================================
@node The Generic Object Head
@section The Generic Object Head

@cindex object head in ZIO
All data structures that refer to a ZIO object include a
@code{zio_obj_head} structure.  The head collects a few fields that
are used across ZIO for object management (including the structure
that is used in building the @i{sysfs} tree).
@c FIXME: document object head to more detail

@c ==========================================================================
@node The Peripheral Driver
@section The Peripheral Driver

@cindex peripheral driver
@cindex device driver
@cindex driver
In order to write a ZIO peripheral driver, you need to define
all three levels of data structures (device, cset, channel), so this
chapter describes the important fields of those structures. It then
offers an overview of the registration steps and an example.

Unless you want to know all the details immediately, at a first read
we suggest to skip the first sections and jump to @ref{The Driver Structure}.

@c --------------------------------------------------------------------------
@node The Device Structure
@subsection The Device Structure

@cindex device
A @i{device} is the description of a complete I/O peripheral device (or
board).


A device is the @i{probe-unit} of ZIO: it
is made up of channel-sets and may represent a PCI
board or an SPI integrated circuit or whatever it makes sense to
manage from a single device driver. The device is primarily a container
of csets, but it also host attributes that affect all csets at the same
time (the attributes
may be defined or not, according to features of the specific
physical device).

The most important fields of @code{struct zio_device} for the developer
are:

@tindex zio_device
@table @code

@cindex cset, array of
@item struct zio_cset *cset
@itemx unsigned int n_cset

	The array of channel sets belonging to this device.

@cindex trigger, preferred
@cindex buffer, preferred
@cindex preferred buffer and trigger
@item char *preferred_buffer
@item char *preferred_trigger

	The device may specify a device-wide default trigger type
	and/or buffer type. This allow a device with an hardware-internal
        trigger to used that as soon as it is initialized, instead
        of requiring the user to select it.  If the fields are NULL
        or the preferred type is not available in the running instance
        of ZIO, the system-wide defaults for buffer and trigger type will
        be used.

@cindex sysfs operations
@tindex zio_sysfs_operations
@item const struct zio_sysfs_operations	*s_op

	The structure includes the @code{info_get} and @code{conf_set}
        methods that act on ZIO attributes. See @ref{The Attributes}.

@end table

@c --------------------------------------------------------------------------
@node The Cset Structure
@subsection The Cset Structure

@cindex cset
As said, the cset is a homogeneous set of I/O channels belonging to a
single device. All channels in the set have the same physical
characteristics.  This object is the most important in the ZIO device
hierarchy because all data transfers are cset-wide. Each cset includes
a pointer to the current trigger and buffer types, because the current
types are two cset-wide attributes. (We chose to set the preferred type
at device level because this fits most use cases, while avoiding
the need to repeat the default for each cset).

@tindex zio_cset
The most important fields of @code{struct zio_cset} to be filled
or used by the developer are:

@table @code

@cindex raw_io
@item int (*raw_io)(struct zio_cset *cset)

	This is the function that performs actual I/O or schedules it
        to be performed when the internal trigger fires. If the
        function returns 0, the input or output operation is already
        completed. A return value of @code{-EAGAIN} means that
        cset code will call @code{zio_trigger_data_done()} at a later time.
        Other return values are used to report real errors.

@cindex sample size
@item  unsigned ssize

	The sample size, in bytes, for each channel in the cset.
        Different channels may feature a different number of
        significant bits, but they must use the same number of bytes in the
        data blocks.

@cindex ZIO_CSET_TYPE_DIGITAL
@cindex ZIO_CSET_TYPE_ANALOG
@cindex ZIO_CSET_TYPE_TIME
@cindex ZIO_CSET_SELF_TIMED
@cindex ZIO_DIR_INPUT
@cindex ZIO_DIR_OUTPUT
@item unsigned long flags

	A few flags, the most important being the type of cset:
        @code{ZIO_CSET_TYPE_DIGITAL},
        @code{ZIO_CSET_TYPE_ANALOG} or @code{ZIO_CSET_TYPE_TIME} (other types
        may be added in the future, we reserved for 8 of them), OR'd with
        @t{ZIO_DIR_INPUT} or @t{ZIO_DIR_OUTPUT}.  Then, if you set
        @t{ZIO_CSET_SELF_TIMED} for an input cset, the trigger will be
        immediately armed, so the driver can fill blocks when its time
        arrives -- for self-timed csets you should use the default
        trigger, which is transparent to user and device actions.

@cindex channel template
@item struct zio_channel *chan_template

	This points to a channel structure that is used by ZIO as
        a template. All channels in the cset are homogeneous, so ZIO
        allocates the array of channels when the cset is registered,
        by replicating this template and updating the @i{index} value for
        each of them. Please refer to existing code for examples.

@item unsigned int n_chan

	The number of channels in this cset.

@cindex array of channels
@item struct zio_channel *chan

	The array of channels, allocated by ZIO at registration time.

@cindex private pointers in the cset
@item void *priv_d

	A private pointer for the device, in case it needs it.

@cindex cset, init and exit functions
@cindex init function for the cset
@cindex exit function for the cset
@item int (*init)(struct zio_cset *cset)
@itemx void (*exit)(struct zio_cset *cset)

	The function pointers, if not NULL, are called by ZIO at
        cset registration and removal time, after allocating (before
        removing) the channel array. They may useful to resp. setup
        and release the @code{priv_d} field.

@end table

@c --------------------------------------------------------------------------
@node The Channel
@subsection The Channel

@cindex channel
@cindex Etherbone
The channel is the lowest-level object in the ZIO hierarchy.  It
represents the individual connector of the device, most likely a
socket in some backplane of some computer (local or remote, in case
@i{Etherbone} is being used).  A channel may also be a software
simulation of a data source/sink of some time.

@tindex zio_channel
The most important fields of @code{struct zio_channel} for the user
are:

@table @code

@cindex private pointers in the channel
@item void *priv_d

	A private pointer for the device (may be allocated by the
        @code{init} function of the cset and released by the corresponding
        @code{exit} function).

@item void *priv_t

	Private data for the trigger, that may be used by the trigger
        during operation. If used, the trigger must allocate it at create time
        and free it at destroy time.

@end table

@c --------------------------------------------------------------------------
@node The Driver Structure
@subsection The Driver Structure

The top-level structure that devices a device driver is similar to
what is used with PCI or USB. This is the definition of the @t{zio_driver}:

@tindex zio_driver
@smallexample
struct zio_driver {
        const struct zio_device_id      *id_table;
        int (*probe)(struct zio_device *dev);
        int (*remove)(struct zio_device *dev);
        struct device_driver            driver;
};
@end smallexample

The client module, thus, must specify a table of device types it is
able to drive. When a match is found, the ZIO core calls the method
@i{probe}, which can return success (zero) or failure (a negative error
code).  Similarly, the core calls @i{remove} when the device disappears 
or the driver is unloaded. Both methods are optional (if missing,
success is assumed).

The @t{driver} sub-structure must be filled in its @i{name} and @i{owner}
fields. See @ref{An Example Driver}.


@cindex identifier table
@cindex table of identifiers
@cindex device name
@cindex match function
The table of identifiers, then, is defined like this in for ZIO devices:

@tindex zio_device_id
@smallexample
struct zio_device_id {
        char                    name[ZIO_OBJ_NAME_LEN];
        struct zio_device       *template;
};
@end smallexample

The @t{name} field is a 12-byte string, the same string that is part
of the control block.  The @t{template} is a a filled ZIO device,
the the core replicates for each and every device matching the name.

The @t{id_table} field in @t{zio_driver} is a pointer to an array of
identifiers; the array is terminated with an empty entry, as customary
in many Linux subsystems.

@c --------------------------------------------------------------------------
@node Registering a ZIO Driver
@subsection Registering a ZIO Driver

By virtue of how the Linux bus abstraction works, registering a ZIO
device is a two-step procedure, based on the above data structures.

The client driver must register a @t{struct zio_driver}, with the
associated table of identifiers; when the core finds a match, it
allocates a new device instance and calls the @i{probe} method.
Please note that the @t{zio_device} passed to the @i{probe} method
is not the template, but a copy of it -- this is mandatory in order
to support several devices of the same type running on the same host.

If, for some reason, you need to save some private data in the device
structure, you must do that in the @i{probe} function for each new
device instance -- and undo any step in the associated @i{remove}
function.

If your driver is able to drive two or more devices, that are similar
in nature but feature a different number of csets or differ in some
other detail, you should fill your table with more than one device
type, each of them with a different name.

@c --------------------------------------------------------------------------
@node Registering a ZIO Device
@subsection Registering a ZIO Device

@cindex registering a device
@cindex device registration
In order to register a device, you need to allocate it from the ZIO
core, and then register it by passing a name and a unique @t{dev_id}
value.  We agree that this is not completely inutuitive, but it is
retained for backward compatibility.

The steps, in practice are:

@itemize @bullet

@item Allocate a generic device;
@item Fill the @i{owner} filed with @t{THIS_MODULE}, for refcounting;
@item Register it in the ZIO core, with a name and a unique numeric ID.

@end itemize

This, for example, is how @i{zio-zero} allocates and registers its
device:

@smallexample
    struct zio_device *zzero_dev;

    zzero_dev = zio_allocate_device();
    if (IS_ERR(zzero_dev)) {
            err = PTR_ERR(zzero_dev);
            goto out_all;
    }
    zzero_dev->owner = THIS_MODULE;
    err = zio_register_device(zzero_dev, "zzero", 0);
@end smallexample

@cindex removing a device
@cindex unregistering a device
@cindex device removal
When the module is removed, the device must be unregistered and released:

@smallexample
    zio_unregister_device(zzero_dev);
    zio_free_device(zzero_dev);
@end smallexample

@c --------------------------------------------------------------------------
@node An Example Driver
@subsection An Example Driver

This is an example of all the data structures need to define
a ZIO device driver. The code comes from @i{zio-mini}:

@smallexample
static struct zio_cset zmini_cset[] = {
        {
                ZIO_SET_OBJ_NAME("timespec-in"),
                .raw_io =       zmini_input,
                .flags =        ZIO_DIR_INPUT,
                .n_chan =       1, /* changed at insmod */
                .ssize =        sizeof(struct timespec),
        },
};

static struct zio_device zmini_tmpl = {
        .owner =                THIS_MODULE,
        .cset =                 zmini_cset,
        .n_cset =               ARRAY_SIZE(zmini_cset),
};

/* The driver uses a table of templates */
static const struct zio_device_id zmini_table[] = {
        {"zmini", &zmini_tmpl},
        {},
};

static struct zio_driver zmini_zdrv = {
        .driver = {
                .name = "zmini",
                .owner = THIS_MODULE,
        },
        .id_table = zmini_table,
};
@end smallexample

With these structures in place, the @i{init} function of the module
will just need to call ``@t{zio_register_driver(&zmini_zdrv)}''.
Actually, the data structures above are more than half of the complete
driver: the only missing bit is the @t{raw_io} cset method, because
triggering, buffering and everything else is manage automatically by
the ZIO framework.

This is a very simple case, where the table includes only one entry,
the device has only one cset and there's no need for @i{probe} and
@i{remove}.  The seemingly-unneeded extra levels are there in order to
be able to support more complex cases, including the common situation
where more than one device is driven by a single host.


@c ==========================================================================
@node The Trigger
@section The Trigger

@cindex trigger
Every data exchange, either input or output, is executed in response
to an event of some kind. ZIO offers a @i{trigger} abstraction
to describe all such events and configure their activation.

Each cset is using a trigger type, and a specific instance of that type.
Different csets can use different trigger types, because the
@code{current_trigger} is an attribute of each cset.  When the trigger
fires, it acts on all the non-disabled channels of the cset.

@cindex input and triggers
@cindex output and triggers
@cindex trigger in input and output flows
For input data flows, the trigger receives blocks from the device and
stores them in the buffer. For output data flows the trigger retrieves
blocks from the buffer and sends them to the device.

@c FIXME: where does the control block come from?

@cindex trigger type, defining
When defining a new trigger type, the most important fields of
@code{struct zio_trigger_type} for the programmer are the following
ones:
@c FIXME: full definition of trigger_type

@tindex zio_sysfs_operations
@table @code
@item const struct zio_sysfs_operations	*s_op

	These are the operations used to read and write attributes.
        It is the same structure used in the device.

@item const struct zio_trigger_operations *t_op

	The trigger operations, expanded below, are the ones that
        implement the behavior of a trigger type.
@end table

The trigger operations are defined by the following structure:

@tindex zio_trigger_operations
@smallexample
struct zio_trigger_operations {
        int                     (*push_block)(struct zio_ti *ti,
                                              struct zio_channel *chan,
                                              struct zio_block *block);
        void                    (*pull_block)(struct zio_ti *ti,
                                              struct zio_channel *chan);

        void                    (*data_done)(struct zio_cset *cset);

        int                     (*config)(struct zio_ti *ti,
                                          struct zio_control *ctrl);

        struct zio_ti *         (*create)(struct zio_trigger_type *trig,
                                          struct zio_cset *cset,
                                          struct zio_control *ctrl,
                                          fmode_t flags);
        void                    (*destroy)(struct zio_ti *ti);
        void                    (*change_status)(struct zio_ti *ti,
                                                 unsigned int status);
        void                    (*abort)(struct zio_cset *cset);
};
@end smallexample

The detailed meaning of the operations is as follows:

@table @code

@cindex create, for triggers
@cindex destroy, for triggers
@item create
@itemx destroy

	The operations are called when this trigger type is associated to
        (resp. de-associated from) a new cset. @code{create} returns
        a trigger instance structure, which is usually part of a larger
        structure that the instance itself will recover with the macro
        @code{container_of}. Please look at existing triggers for details

@cindex push_block
@item push_block

	When a buffer has a complete block of data, it can send it to
        the trigger using @code{push_block}. The trigger can either accept it
        (returns 0) or not (returns @code{-EBUSY}). This because an
        output trigger has only one pending data transfer. When the block is
        consumed, the trigger will call @code{bi->retr_block} to get the next
        one.  Buffering is in the buffer, not in the trigger.
@c FIXME: check push_block for double buffering

@cindex pull_block
@item pull_block

	For input channels, a buffer may call @code{pull_block}. The trigger
        may thus fire input directly and later have a block.  Most
        triggers won't support the @code{pull_block} way of doing input,
        they will just call @code{bi->store_block} when
        a new block is available. In these cases the @code{pull_block}
        method can be left @code{NULL}.

@cindex data_done
@item data_done

	This method, if defined, is called by the device by means of the helper
        @t{zio_trigger_data_done()}. I/O in the device is
        almost always asynchronous, so when asked to transfer a cset,
        the device will prepare to do it, and will call @code{zio_trigger_data_done}
        later. For output csets,
        @code{zio_trigger_data_done} frees the blocks and prepares new blocks
        for the next trigger event; for input, @code{zio_trigger_data_done} pushes
        material to the buffers.  This method, if present, is called
        while holding the @i{cset} spin lock, and the trigger still
        in @t{ARMED} state (@t{zio_trigger_data_done} clears the flag only
        when everything is over with the current trigger event).

@cindex config for triggers
@item config

	The method is not currently used. The idea is that when
        a channel is configured by sending it a complete new control
        structure, this callback allows the trigger to reconfigure itself.
@c FIXME: use the config trigger method

@item abort
	Abort, if defined, is called when an already-armed trigger event
        must be aborted. This happens, for example, because event
        parameters changed (e.g., the block size).  The method must
        dispose the @i{active_block} for each channel, and set the
        pointer to NULL. The trigger may perform @i{data_done} for
        partially-filled block. The method
        is called while holding the cset lock and cannot fail nor sleep.

@c  The trigger will usually call the @i{stop_io}
@c        device method and optionally may perform @i{data_done} for
@c        partially-filled  blocks. The method
@c        is called while holding the cset lock and cannot fail nor sleep

@item change_status
        The method, if defined, is called when the trigger is enabled or
        disabled. On disable, ZIO calls @i{abort} beforehand.
        The method is called while hoding the cset lock.

@end table

@c ==========================================================================
@node The Buffer
@section The Buffer

@cindex buffer
The buffer interface in ZIO allows to select between different
allocation techniques and memory access. By splitting the buffer
to a separate ZIO object, the framework allows drivers with special
allocation needs to define their own hardware-specific buffer.

@cindex csets and buffers
Each cset is using a buffer type, for which an instance exists for
each channel in the cset. Data transfers only happen if a channel
is enabled, so different buffers instances in the cset may at
times host a different number of blocks, but this is not the usual case.

The most important fields of @code{struct zio_buffer_type}, from
the point of view of the developer of anew buffer, are the various
operations structures:

@c FIXME: full definition of buffer_type

@tindex zio_buffer_type
@table @code

@item const struct zio_buffer_operations *b_op

	The buffer operations, detailed later, are the function
        that define the actual behavior of a buffer.

@cindex file operations
@item const struct file_operations *f_op

	File operations are used to provide user-space access to
        the buffer. ZIO exports a @code{zio_generic_fops} structure
        that will work for most users. This pointer will be removed when
        the @i{interface} idea is implemented.

@cindex virtual memory operations
@cindex mmap support
@item const struct vm_operations_struct	*v_op

	Buffer types supporting @i{mmap} must implement the
        virtual memory operations. They allow to keep track of active
        uses of the buffer instance and handle page faults for
        program accessing the buffer.  The operations are associated
        to each @code{vma} mapped to the char device associated to
        a buffer instance of this type. Use is exactly like what
        you do in normal char drivers, with the only difference the
        the @code{open} method is called when @i{mmap} happens.
        Please refer to the @code{zio-buf-vmalloc} implementation for
        details.
@c FIXME: vmalloc reference to in-manual vmalloc desc

@end table

The buffer operations are defined as follows:

@tindex zio_buffer_operations
@smallexample
struct zio_buffer_operations {
        struct zio_block *      (*alloc_block)(struct zio_bi *bi,
                                               size_t datalen, gfp_t gfp);
        void                    (*free_block)(struct zio_bi *bi,
                                              struct zio_block *block);

        int                     (*store_block)(struct zio_bi *bi,
                                               struct zio_block *block);
        struct zio_block *      (*retr_block) (struct zio_bi *bi);

        struct zio_bi *         (*create)(struct zio_buffer_type *zbuf,
                                          struct zio_channel *chan);
        void                    (*destroy)(struct zio_bi *bi);
};
@end smallexample

This is the specific role of each method in the structure:

@table @code

@cindex create, for buffers
@cindex destroy, for buffers
@item create
@itemx destroy

	When ZIO associates a buffer with a new channel, it calls the
        @code{create} operation. The returned @code{zio_bi} structure
        will usually be part of a bigger structure used internally
        by the buffer implementation, using the @code{container_of}
        macro to access it from the @code{zio_bi} pointer. If creation
        fails, the method must return an @t{ERR_PTR} value, not NULL.

@cindex alloc_block
@cindex free_block
@item alloc_block
@itemx free_block

	The buffer is concerned with memory management, so whenever
        the trigger or the @i{write} system call need a new block,
        they ask it to the buffer type. Similarly, the buffer type
        is asked to release blocks. The function must also allocate
        the control, likely with @t{zio_alloc_control}. Such control
        will be filled with the current values for the channel in due time.
        (For input this copy happens late). On error it return NULL.

@cindex store_block
@cindex retr_block
@item store_block
@itemx retr_block

	The functions simply add a block to an existing buffer instance
        or ask to retrieve a block out of it.  In addition to managing
        storage according to its own will, the buffer is requested to
        make two special actions. When @code{store_block} inserts
        the first block in an empty output buffer, the method must
        call the @code{push_block} method of the associated trigger.
        When @code{retr_block} asks for a block from an empty input buffer,
        the method must call @code{pull_block} in the associated trigger,
        if not NULL. Please refer to existing implementations
        for details.

@end table

@c ==========================================================================
@node The Attributes
@section The Attributes

Still to be written. Feel free to express your interest in this
section to the mailing list.

@c ##########################################################################
@node Available Modules
@chapter Available Modules

@c FIXME: include the list of types and abbreviations (from the wiki)

The current ZIO repository includes a number of modules for devices
triggers and buffers.  They are meant to act as test cases, examples
and tools to stress-test the code.  Some of them are useful in the
real world, despite their simple and straightforward design.

The first hardware parts for the real use cases are going to be
available during February 2012, so this list will soon increase.

@c ==========================================================================
@node Available Devices
@section Available Devices

Still to be written. Feel free to express your interest in this
section to the mailing list.

@c ==========================================================================
@node Available Triggers
@section Triggers

Still to be written. Feel free to express your interest in this
section to the mailing list.

@c ==========================================================================
@node Available Buffers
@section Buffers

Still to be written. Feel free to express your interest in this
section to the mailing list.

@c ##########################################################################
@node Writing ZIO Modules
@chapter Writing ZIO Modules

This chapter explains how to write ZIO modules, using existing modules
as a working example. This chapter shows how to use the data structures
described earlier in this manual.

@c ==========================================================================
@node Locking Policies
@section Locking Policies

@cindex locking policies
@cindex spin locks in ZIO
@cindex critical sections
@cindex race conditions
In order to safely work with ZIO, developers should be aware of the
locking policies that are already in place. With this knowledge
they can handle their critical sections without over-locking or
under-locking in preventing race conditions.

In general, we tried to centralize locking in order to simplify the
task of writing ZIO drivers.

The following locks are defined used in ZIO core and data structures:

@table @code

@item zio_status->lock

	This is used internally to take care of all registered devices,
        csets, trigger types and buffer types. The core hosts a list
        for each of the item types and a single lock is used for all
        of them.  These lists, anyways, can be modified only when ZIO
        modules register or unregister themselves.

@cindex device lock
@item zio_device->lock

	This lock is used to serialize every configuration performed
        through zio attributes. This applies to all configurations
        pertaining the device and its dependent levels, including
        buffer and trigger instances. In other words, all @code{conf_set}
        and @code{info_get} calls are serialized device-wise.

@cindex cset lock
@item zio_cset->lock

@c FIXME: trigger-related  flags and locks
	The cset structure includes a lock that is used to
        serialize access to the @code{ti->flags} bits (e.g.:
        @code{ZIO_TI_ARMED}, that signals that a trigger is pending).
        I/O itself is serialized by trigger code in the ZIO core:
        only one trigger event
        can be pending for each cset, using the ARMED flag. The cset
        itself, then,  can use this same lock to serialize other activities
        and prevent a trigger to be armed during such activities.

@item zio_buffer_type->lock
@itemx zio_trigger_type->lock

	Each buffer and trigger type has a lock, which is used
        by the core when instances are created or destroyed. Thus,
        such operations are serialized and sub-modules are safe without
        arranging for their own locking policies.

@item zio_bi->lock
@itemx zio_ti->lock

	These locks are initialized by the core before calling the
        respective create function. Buffer and trigger types can use
        them without declaring a spinlock in their own structures.
        Buffers distributed with the core use this lock.

@end table

From the table above, it's clear how the device lock, used for
configuration, is the ZIO spinlock with the widest scope.  Even though
device, buffer and trigger are registered as different objects, they
live on the same peripheral device. Thus, you most often need to
serialize configuration on the device as a whole, because
configuration parameters are usually stored in hardware registers.

If the trigger and buffer modules are device-specific, they may need
to access the device spin lock, too. While this doesn't apply to
generic triggers or buffers, taking the device lock won't have bad
effects, and the associated overhead is minimal.

If your buffers or triggers request a different kind of locking
(e.g., you need to serialize some sections with a scope bigger
than the single device), you'll need to arrange for your own locking.

The following lines show how to reach the device lock from the various
objects used withing the ZIO framework:

@example
   zio_device->lock
   zio_cset->zdev->lock
   zio_channel->cset->zdev->lock
   zio_ti->cset->zdev->lock
   zio_bi->cset->zdev->lock
@end example

The device lock is also used to protect the enable/disable bit of
device, cset, channel and trigger instance.  For this reason,
please note that the @i{abort} and @i{change_status} trigger
operations are called while holding the device lock.

ZIO sub-modules should arrange for any other locking requirements.
Buffer modules will typically ensure consistency of the data space
within each instance (i.e., concurrency of @code{store_block} and
@code{retr_block}) (they can use @code{bi->lock} for this).  Trigger
modules will need to protect modification of their status flag, like
the utility functions @code{zio_generic_data_done} and
@code{zio_fire_trigger} do (they can use @code{ti->lock} to this aim).
Device modules will need to serialize some of their non-atomic
hardware access primitives, in this case by declaring their own locks.

@c ==========================================================================
@node Writing a Device
@section Writing a Device

Still to be written. Feel free to express your interest in this
section to the mailing list.

@c ==========================================================================
@node Writing a Trigger
@section Writing a Trigger

Still to be written. Feel free to express your interest in this
section to the mailing list.

@c ==========================================================================
@node Writing a Buffer
@section Writing a Buffer

Still to be written. Feel free to express your interest in this
section to the mailing list.

@page
@c ##########################################################################
@node Index
@unnumbered Index

@printindex cp
@bye


@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent sysfs
@c  LocalWords:  setchapternewpage finalout timestamping timestamp csets gpio
@c  LocalWords:  ohwr cset cindex itemx inutuitive
